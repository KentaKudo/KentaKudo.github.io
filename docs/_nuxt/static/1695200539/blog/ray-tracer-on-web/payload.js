__NUXT_JSONP__("/blog/ray-tracer-on-web", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT){return {data:[{page:{slug:"ray-tracer-on-web",description:"I have been working on writing a ray tracer in Rust in the last few weeks. This post is to show off what I could achieve:)",title:"Ray Tracer on Web",language:"en\u002FGB",tags:["raytracing","rust"],image:{src:"laser.jpg",alt:"Laser beams in darkness",credit:"Photo by \u003Ca href=\"https:\u002F\u002Funsplash.com\u002F@clyde_he?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\"\u003EClyde He\u003C\u002Fa\u003E on \u003Ca href=\"https:\u002F\u002Funsplash.com\u002Fs\u002Fphotos\u002Flight?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\"\u003EUnsplash\u003C\u002Fa\u003E"},createdAt:"2022-03-03T00:00:00.000Z",toc:[{id:ai,depth:M,text:aj},{id:ak,depth:A,text:al},{id:am,depth:A,text:an},{id:ao,depth:A,text:ap},{id:aq,depth:M,text:ar},{id:as,depth:A,text:at},{id:F,depth:A,text:F},{id:au,depth:A,text:av},{id:aw,depth:A,text:ax},{id:ay,depth:M,text:az},{id:aA,depth:M,text:Y}],body:{type:"root",children:[{type:b,tag:g,props:{},children:[{type:a,value:"First things first: demonstration. Try clicking the Run button below. It's going to take a bit while until the result pops up, so please be patient:)"}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"(NOTE: Web Worker must be "},{type:b,tag:i,props:{href:"https:\u002F\u002Fcaniuse.com\u002Fwebworkers",rel:[k,l,m],target:n},children:[{type:a,value:"supported"}]},{type:a,value:" on your browser.)"}]},{type:a,value:e},{type:b,tag:"ray-tracer-canvas",props:{},children:[{type:a,value:e}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"It didn't load the image but "},{type:b,tag:aB,props:{},children:[{type:a,value:"generated it on your device"}]},{type:a,value:" using the power of Web Assembly. Because it has some random factor, it produces slightly different images every time you run it."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"It's cool, isn't it?"}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"I'm first going to touch on what ray tracer \u002F ray tracing is for those who are not familiar with it. Then look at details of how I ran it in the browser."}]},{type:a,value:e},{type:b,tag:"aside",props:{},children:[{type:a,value:"\nMany thanks to "},{type:b,tag:i,props:{href:"https:\u002F\u002Ftwitter.com\u002FPeter_shirley"},children:[{type:a,value:"@Peter_shirley"}]},{type:a,value:" who wrote a phenomenal tutorial "},{type:b,tag:i,props:{href:aC},children:[{type:a,value:aD}]},{type:a,value:". I just followed his tutorial using Rust instead of C++.\n"}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"The source code is available on "},{type:b,tag:i,props:{href:"https:\u002F\u002Fgithub.com\u002FKentaKudo\u002Fwasm-raytracer",rel:[k,l,m],target:n},children:[{type:a,value:"GitHub"}]},{type:a,value:", and also published as a "},{type:b,tag:i,props:{href:"https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fwasm-raytracer",rel:[k,l,m],target:n},children:[{type:a,value:"NPM package"}]},{type:a,value:z}]},{type:a,value:e},{type:b,tag:N,props:{id:ai},children:[{type:b,tag:i,props:{href:"#whats-ray-tracing",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:aj}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Ray tracing is a technique used to render a scene. Pay close attention to the shadows and the reflection on water, walls, floors, and glasses in this video."}]},{type:a,value:e},{type:b,tag:O,props:{className:["embed","mb"]},children:[{type:a,value:G},{type:b,tag:"iframe",props:{width:560,height:315,src:"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FXf2QCdScU6o",title:"YouTube video player",frameBorder:P,allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowFullScreen:true},children:[]},{type:a,value:e}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"You may find the scene rendered by ray tracing more natural."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"While ray tracing is computationaly more expensive than the widely used method "},{type:b,tag:H,props:{},children:[{type:a,value:"rasterisation"}]},{type:a,value:", it's been increasing its presence in movie and game rendering with the help of the latest advance in GPU technology."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Programatically, it calculates the colour of each pixel in the image from top left to right bottom tracing \"rays\" from a \"camera\" to the \"scene\"."}]},{type:a,value:e},{type:b,tag:B,props:{id:ak},children:[{type:b,tag:i,props:{href:"#scene",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:al}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"A scene is the world where all the objects, for example cars, lights, buildings, and so on, are placed. My ray tracer only has simple spheres as they're easy to model, but you can put literally any objects in any positions if you manage to model it."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"You can add other factors to objects to make it look more real. One such factor is a "},{type:b,tag:aB,props:{},children:[{type:a,value:"material"}]},{type:a,value:" the object is made of. Depending on the material, the object behaves differently when a ray hits. Materials supported by my version of ray tracer are:"}]},{type:a,value:e},{type:b,tag:Q,props:{},children:[{type:a,value:e},{type:b,tag:p,props:{},children:[{type:a,value:"Lambertian — a material that reflects the ray to a random direction,"}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:a,value:"Metal — a material that reflects the ray to the direction calculated from the incoming ray's angle, and"}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:a,value:"Dielectric (glasses) — a material that refracts the ray to the inside of the object."}]},{type:a,value:e}]},{type:a,value:e},{type:b,tag:Z,props:{src:"blog\u002Fray-tracer-on-web\u002Fmaterials.png",alt:"Lambertian casts a ray to a random direction, Metal reflects, Dielectric refracts",caption:"Each material baheves differently when a ray hits it"},children:[{type:a,value:e}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Once you define a scene, the next thing you need to do is to specify where you look at the scene from."}]},{type:a,value:e},{type:b,tag:B,props:{id:am},children:[{type:b,tag:i,props:{href:"#camera",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:an}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"A camera is your eyes. All the rays start their journey from the camera. It's defined with two main parameters:"}]},{type:a,value:e},{type:b,tag:Q,props:{},children:[{type:a,value:e},{type:b,tag:p,props:{},children:[{type:a,value:"position — the place where you look at the scene from, and"}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:a,value:"atitude — the direction of its gaze"}]},{type:a,value:e}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"In addition to them, you also need to configure\n(1) a viewport which has the same aspect ratio as the final image, think it as a window which you look at the scene through, and\n(2) the distance between the camera and the viewport, which is called \"focal length\"."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Once the camera is positioned, it's ready to start casting rays."}]},{type:a,value:e},{type:b,tag:B,props:{id:ao},children:[{type:b,tag:i,props:{href:"#ray",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:ap}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"A ray is casted from the camera to the direction of the pixel it's interested in at the time. The casted ray may or may not hit objects placed in the scene. If it hits something, it first records the color of the object surface. Then, it produces another ray, the direction of which depends on the material of the object as explained in the scene section, from the hit point."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"The tracing of the ray stops either\n(1) when the ray goes deep into the shadow or\n(2) when it doesn't hit anything anymore, which means it reaches the ambient light (or sky so to speak).\nThe final colour of the pixel is calculated at that point."}]},{type:a,value:e},{type:b,tag:Z,props:{src:"blog\u002Fray-tracer-on-web\u002Fray.png",alt:"A ray is cast from a camera to the scene through a frame in between them calculating the final colour of the pixel",caption:"Tracing the journey of the ray"},children:[{type:a,value:e}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"This is a quick explanation of what the ray tracer is. See the "},{type:b,tag:i,props:{href:aE},children:[{type:b,tag:H,props:{},children:[{type:a,value:Y}]}]},{type:a,value:" section to continue reading more about ray tracing if you're interested."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Now, let's talk about what I did to run it on web browser."}]},{type:a,value:e},{type:b,tag:N,props:{id:aq},children:[{type:b,tag:i,props:{href:"#ray-tracer--web-assembly",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:ar}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"The first thing I had to do was make a decision on how JavaScript and Rust should communicate each other; more precisely, how to pass images from Rust to JavaScript."}]},{type:a,value:e},{type:b,tag:B,props:{id:as},children:[{type:b,tag:i,props:{href:"#canvas-api",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:at}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"To draw an image on the screen, I used the \u003Ccanvas\u003E HTML element. Its "},{type:b,tag:o,props:{},children:[{type:a,value:"putImageData()"}]},{type:a,value:" API receives input image as an "},{type:b,tag:o,props:{},children:[{type:a,value:aF}]},{type:a,value:" object, and the image data is given as "},{type:b,tag:o,props:{},children:[{type:a,value:R}]},{type:a,value:", which is expected to be an array containing the pixel data in the RGBA order."}]},{type:a,value:e},{type:b,tag:Z,props:{src:"blog\u002Fray-tracer-on-web\u002Fcanvas-api.png",alt:"Uint8ClampedArray is used for ImageData then passed to canvas HTML element."},children:[{type:a,value:e}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Long story short, the goal is to return a properly serialised "},{type:b,tag:o,props:{},children:[{type:a,value:R}]},{type:a,value:" from the Rust programme."}]},{type:a,value:e},{type:b,tag:B,props:{id:F},children:[{type:b,tag:i,props:{href:"#wasm-bindgen",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:F}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:b,tag:i,props:{href:"https:\u002F\u002Fgithub.com\u002Frustwasm\u002Fwasm-bindgen",rel:[k,l,m],target:n},children:[{type:a,value:F}]},{type:a,value:" is a library that bridges the gap between JavaScript and the Web Assembly module written in Rust."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"What I needed to do so the "},{type:b,tag:o,props:{},children:[{type:a,value:_}]},{type:a,value:" function can be called from JavaScript and return "},{type:b,tag:o,props:{},children:[{type:a,value:R}]},{type:a,value:" was to add a "},{type:b,tag:o,props:{},children:[{type:a,value:aG}]},{type:a,value:" annotation and modify the return type:"}]},{type:a,value:e},{type:b,tag:O,props:{className:[$]},children:[{type:b,tag:aa,props:{className:[ab,"language-rust"]},children:[{type:b,tag:o,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:"use"}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,"namespace"]},children:[{type:a,value:"wasm_bindgen"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:aH}]},{type:a,value:"prelude"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:aH}]}]},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:"*"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:"\n\n"},{type:b,tag:c,props:{className:[d,"attribute","attr-name"]},children:[{type:a,value:aG}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:"pub"}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:"fn"}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,"function-definition",y]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:"width"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:ac}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:aI}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:D}]},{type:a,value:" height"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:ac}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:aI}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:"-\u003E"}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,ad]},children:[{type:a,value:R}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:I}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,ae]},children:[{type:a,value:"\u002F\u002F ...setup a scene and a camera"}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:"let"}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:"mut"}]},{type:a,value:" img "},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:C}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,"macro",aJ]},children:[{type:a,value:"vec!"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:J}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,ae]},children:[{type:a,value:"\u002F\u002F ...build image"}]},{type:a,value:S},{type:b,tag:c,props:{className:[d,ae]},children:[{type:a,value:"\u002F\u002F convert from [u8] to Uint8ClampedArray using Into trait."}]},{type:a,value:"\n  img"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:J}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:".."}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:"into"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:L}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"This is basically everything I needed to run the ray tracer in web browser, but there was one issue when I tried it: the browser got stuck while running the ray tracer. What I was missing was to follow this advice:"}]},{type:a,value:e},{type:b,tag:"blockquote",props:{},children:[{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"The main thread in a browser cannot block. This means that if you run WebAssembly code on the main thread you can never block, meaning you can't do so much as acquire a mutex. This is an extremely difficult limitation to work with on the web, although one workaround is to run wasm exclusively in web workers and run JS on the main thread. It is possible to run the same wasm across all threads, but you need to be extremely vigilant about synchronization with the main thread. —— "},{type:b,tag:i,props:{href:"https:\u002F\u002Frustwasm.github.io\u002Fwasm-bindgen\u002Fexamples\u002Fraytrace.html#caveats",rel:[k,l,m],target:n},children:[{type:a,value:"Parallel Raytracing#caveats"}]}]},{type:a,value:e}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Because ray tracing takes some time and blocks the thread where it runs, running it on the main thread is a no-no; I made a first encounter to Web Worker...!"}]},{type:a,value:e},{type:b,tag:B,props:{id:au},children:[{type:b,tag:i,props:{href:"#web-worker",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:av}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Regardless of its unfriendly interface ("},{type:b,tag:i,props:{href:"https:\u002F\u002Fgithub.com\u002FGoogleChromeLabs\u002Fcomlink",rel:[k,l,m],target:n},children:[{type:a,value:"Comlink"}]},{type:a,value:" can be a help for it), using Web Worker is not super complicated."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"The main thread needs to (1) instantiate a worker specifying the path to the worker file, (2) invoke it passing arguments via "},{type:b,tag:o,props:{},children:[{type:a,value:T}]},{type:a,value:" API, and (3) listen to the result by registering an "},{type:b,tag:o,props:{},children:[{type:a,value:U}]},{type:a,value:" callback:"}]},{type:a,value:e},{type:b,tag:O,props:{className:[$]},children:[{type:b,tag:aa,props:{className:[ab,aK]},children:[{type:b,tag:o,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:V}]},{type:a,value:" w "},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:C}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:aL}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,ad]},children:[{type:a,value:"Worker"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,af]},children:[{type:a,value:"\"..\u002Fpath\u002Fto\u002Fthe\u002Fworker\u002Ffile\""}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:aM},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,W,y,E]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:J}]},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:aN}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:D}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:"HEIGHT"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:aM},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,"method-variable",aO,W,y,E]},children:[{type:a,value:U}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:C}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,aP]},children:[{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:I}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,"literal-property",aJ]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:ac}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:L}]}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,"arrow",x]},children:[{type:a,value:"=\u003E"}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:I}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:V}]},{type:a,value:" imageData "},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:C}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:aL}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,ad]},children:[{type:a,value:aF}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:aR},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:D}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:aN}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:"\n  canvas"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,W,y,E]},children:[{type:a,value:"getContext"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,af]},children:[{type:a,value:"\"2d\""}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,W,y,E]},children:[{type:a,value:"putImageData"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:"imageData"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:D}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,X]},children:[{type:a,value:P}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:D}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,X]},children:[{type:a,value:P}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:L}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"The worker in return defines an "},{type:b,tag:o,props:{},children:[{type:a,value:U}]},{type:a,value:" method, calls the wasm function, and pass back the result using "},{type:b,tag:o,props:{},children:[{type:a,value:T}]},{type:a,value:" API:"}]},{type:a,value:e},{type:b,tag:O,props:{className:[$]},children:[{type:b,tag:aa,props:{className:[ab,aK]},children:[{type:b,tag:o,props:{},children:[{type:b,tag:c,props:{className:[d,aO,y]},children:[{type:a,value:U}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:C}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:"async"}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:y}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,aP]},children:[{type:a,value:aS}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:I}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:V}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:I}]},{type:a,value:" render "},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:L}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:C}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j,"control-flow"]},children:[{type:a,value:"await"}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,j,"module"]},children:[{type:a,value:"import"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,af]},children:[{type:a,value:"\"wasm-raytracer\""}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:V}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,x]},children:[{type:a,value:C}]},{type:a,value:h},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:aS},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:J}]},{type:b,tag:c,props:{className:[d,X]},children:[{type:a,value:P}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:D}]},{type:a,value:" e"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:z}]},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:J}]},{type:b,tag:c,props:{className:[d,X]},children:[{type:a,value:"1"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:K}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,y]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:aR},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:L}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"This was all I needed to run ray tracer on a dedicated thread."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Before closing the section, I address the performance issue I tried to solve."}]},{type:a,value:e},{type:b,tag:B,props:{id:aw},children:[{type:b,tag:i,props:{href:"#multi-threading",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:ax}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Even though now it's separated from the main thread, running it on a single thread takes a bit of time. To improve performance, I looked at options to run it on multiple threads."}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"The calculation of each pixel can be done in isolatation from each other, and "},{type:b,tag:H,props:{},children:[{type:a,value:"fork-join parallelism"}]},{type:a,value:", which is to "},{type:b,tag:H,props:{},children:[{type:a,value:"fork"}]},{type:a,value:" to start a new thread and to join to "},{type:b,tag:H,props:{},children:[{type:a,value:"wait"}]},{type:a,value:" for it to finish, can be applied using libraries such as "},{type:b,tag:i,props:{href:"https:\u002F\u002Fgithub.com\u002Frayon-rs\u002Frayon",rel:[k,l,m],target:n},children:[{type:a,value:"Rayon"}]},{type:a,value:z}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"Even though it wasn't difficult to turn the programme into the multi-thread version, there were a couple of challenges to run it in the browser environment:"}]},{type:a,value:e},{type:b,tag:Q,props:{},children:[{type:a,value:e},{type:b,tag:p,props:{},children:[{type:a,value:"WebAssembly threads are not supported by "},{type:b,tag:i,props:{href:"https:\u002F\u002Fwebassembly.org\u002Froadmap\u002F",rel:[k,l,m],target:n},children:[{type:a,value:"some browsers"}]},{type:a,value:" yet."}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:a,value:"To enable it, "},{type:b,tag:i,props:{href:"https:\u002F\u002Fweb.dev\u002Fcoop-coep\u002F",rel:[k,l,m],target:n},children:[{type:a,value:"COOP and COEP headers"}]},{type:a,value:" need to be configured properly, which is not possble for GitHub pages where this blog is hosted as of today."}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:a,value:"Because Rust's wasm build target doesn't assume it's going to be run in browsers, the standard library "},{type:b,tag:o,props:{},children:[{type:a,value:"std::thread"}]},{type:a,value:" is not aware of Web Workers that enable WebAssembly threads on browser environments."}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:a,value:"The "},{type:b,tag:i,props:{href:"https:\u002F\u002Fgithub.com\u002FGoogleChromeLabs\u002Fwasm-bindgen-rayon",rel:[k,l,m],target:n},children:[{type:b,tag:o,props:{},children:[{type:a,value:"wasm-bindgen-rayon"}]},{type:a,value:" library"}]},{type:a,value:" enables compiling multi-thread code written with the Rayon library into threads aware wasm, but only with the nightly version of Rust."}]},{type:a,value:e}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"For those reasons, I gave up multi-threading for now hoping I can introduce it in the near future."}]},{type:a,value:e},{type:b,tag:N,props:{id:ay},children:[{type:b,tag:i,props:{href:"#why-ray-tracer",ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:az}]},{type:a,value:e},{type:b,tag:g,props:{},children:[{type:a,value:"This is kind of a detour from my journey of the "},{type:b,tag:aT,props:{to:"\u002Fblog\u002Fcpu-experiment"},children:[{type:a,value:"CPU experiment"}]},{type:a,value:" aimed at understanding what ray tracer is and how to implement it (+ not to mention learning Rust). Next challenge is to migrate the ray tracer programme to the Hack\u002FJack system I built while I was reading the book I introduced in the last section of the "},{type:b,tag:aT,props:{to:"\u002Fblog\u002Fthe-power-of-nand"},children:[{type:a,value:"The Power of NAND"}]},{type:a,value:" post. Bye for now:)"}]},{type:a,value:e},{type:b,tag:N,props:{id:aA},children:[{type:b,tag:i,props:{href:aE,ariaHidden:s,tabIndex:t},children:[{type:b,tag:c,props:{className:[u,v]},children:[]}]},{type:a,value:Y}]},{type:a,value:e},{type:b,tag:Q,props:{},children:[{type:a,value:e},{type:b,tag:p,props:{},children:[{type:b,tag:i,props:{href:aC,rel:[k,l,m],target:n},children:[{type:a,value:aD}]}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:b,tag:i,props:{href:"https:\u002F\u002Fblog.singleton.io\u002Fposts\u002F2022-01-02-raytracing-with-rust\u002F",rel:[k,l,m],target:n},children:[{type:a,value:"The joy of building a ray tracer, for fun, in Rust."}]}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:b,tag:i,props:{href:"https:\u002F\u002Fbheisler.github.io\u002Fpost\u002Fwriting-raytracer-in-rust-part-1\u002F",rel:[k,l,m],target:n},children:[{type:a,value:"Writing a Raytracer in Rust"}]}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:b,tag:i,props:{href:"https:\u002F\u002Fclayto.com\u002F2021\u002F07\u002Fshaking-off-the-rust-2-ray-tracing-in-webassembly\u002F",rel:[k,l,m],target:n},children:[{type:a,value:"Shaking Off the Rust 2: Ray Tracing in WebAssembly"}]}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:b,tag:i,props:{href:"https:\u002F\u002Frustwasm.github.io\u002Fwasm-bindgen\u002Fexamples\u002Fraytrace.html",rel:[k,l,m],target:n},children:[{type:a,value:"Parallel Raytracing"}]}]},{type:a,value:e},{type:b,tag:p,props:{},children:[{type:b,tag:i,props:{href:"https:\u002F\u002Fweb.dev\u002Fwebassembly-threads\u002F",rel:[k,l,m],target:n},children:[{type:a,value:"Using WebAssembly threads from C, C++ and Rust"}]}]},{type:a,value:e}]}]},dir:"\u002Fblog",path:"\u002Fblog\u002Fray-tracer-on-web",extension:".md",updatedAt:"2023-03-31T03:01:52.246Z",bodyPlainText:"\nFirst things first: demonstration. Try clicking the Run button below. It's going to take a bit while until the result pops up, so please be patient:)\n\n(NOTE: Web Worker must be [supported](https:\u002F\u002Fcaniuse.com\u002Fwebworkers) on your browser.)\n\n\u003Cray-tracer-canvas\u003E\u003C\u002Fray-tracer-canvas\u003E\n\nIt didn't load the image but **generated it on your device** using the power of Web Assembly. Because it has some random factor, it produces slightly different images every time you run it.\n\nIt's cool, isn't it?\n\nI'm first going to touch on what ray tracer \u002F ray tracing is for those who are not familiar with it. Then look at details of how I ran it in the browser.\n\n\u003Caside\u003E\nMany thanks to \u003Ca href=\"https:\u002F\u002Ftwitter.com\u002FPeter_shirley\"\u003E@Peter_shirley\u003C\u002Fa\u003E who wrote a phenomenal tutorial \u003Ca href=\"https:\u002F\u002Fraytracing.github.io\u002Fbooks\u002FRayTracingInOneWeekend.html\"\u003ERay Tracing In One Weekend\u003C\u002Fa\u003E. I just followed his tutorial using Rust instead of C++.\n\u003C\u002Faside\u003E\n\nThe source code is available on [GitHub](https:\u002F\u002Fgithub.com\u002FKentaKudo\u002Fwasm-raytracer), and also published as a [NPM package](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fwasm-raytracer).\n\n## What's ray tracing?\n\nRay tracing is a technique used to render a scene. Pay close attention to the shadows and the reflection on water, walls, floors, and glasses in this video.\n\n\u003Cdiv class=\"embed mb\"\u003E\n  \u003Ciframe\n    width=\"560\"\n    height=\"315\"\n    src=\"https:\u002F\u002Fwww.youtube.com\u002Fembed\u002FXf2QCdScU6o\"\n    title=\"YouTube video player\"\n    frameborder=\"0\"\n    allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n    allowfullscreen\n  \u003E\u003C\u002Fiframe\u003E\n\u003C\u002Fdiv\u003E\n\nYou may find the scene rendered by ray tracing more natural.\n\nWhile ray tracing is computationaly more expensive than the widely used method _rasterisation_, it's been increasing its presence in movie and game rendering with the help of the latest advance in GPU technology.\n\nProgramatically, it calculates the colour of each pixel in the image from top left to right bottom tracing \"rays\" from a \"camera\" to the \"scene\".\n\n### Scene\n\nA scene is the world where all the objects, for example cars, lights, buildings, and so on, are placed. My ray tracer only has simple spheres as they're easy to model, but you can put literally any objects in any positions if you manage to model it.\n\nYou can add other factors to objects to make it look more real. One such factor is a **material** the object is made of. Depending on the material, the object behaves differently when a ray hits. Materials supported by my version of ray tracer are:\n\n- Lambertian — a material that reflects the ray to a random direction,\n- Metal — a material that reflects the ray to the direction calculated from the incoming ray's angle, and\n- Dielectric (glasses) — a material that refracts the ray to the inside of the object.\n\n\u003Cnuxt-image src=\"blog\u002Fray-tracer-on-web\u002Fmaterials.png\" alt=\"Lambertian casts a ray to a random direction, Metal reflects, Dielectric refracts\" caption=\"Each material baheves differently when a ray hits it\"\u003E\u003C\u002Fnuxt-image\u003E\n\nOnce you define a scene, the next thing you need to do is to specify where you look at the scene from.\n\n### Camera\n\nA camera is your eyes. All the rays start their journey from the camera. It's defined with two main parameters:\n\n- position — the place where you look at the scene from, and\n- atitude — the direction of its gaze\n\nIn addition to them, you also need to configure\n(1) a viewport which has the same aspect ratio as the final image, think it as a window which you look at the scene through, and\n(2) the distance between the camera and the viewport, which is called \"focal length\".\n\nOnce the camera is positioned, it's ready to start casting rays.\n\n### Ray\n\nA ray is casted from the camera to the direction of the pixel it's interested in at the time. The casted ray may or may not hit objects placed in the scene. If it hits something, it first records the color of the object surface. Then, it produces another ray, the direction of which depends on the material of the object as explained in the scene section, from the hit point.\n\nThe tracing of the ray stops either\n(1) when the ray goes deep into the shadow or\n(2) when it doesn't hit anything anymore, which means it reaches the ambient light (or sky so to speak).\nThe final colour of the pixel is calculated at that point.\n\n\u003Cnuxt-image src=\"blog\u002Fray-tracer-on-web\u002Fray.png\" alt=\"A ray is cast from a camera to the scene through a frame in between them calculating the final colour of the pixel\" caption=\"Tracing the journey of the ray\"\u003E\u003C\u002Fnuxt-image\u003E\n\nThis is a quick explanation of what the ray tracer is. See the [_References_](#references) section to continue reading more about ray tracing if you're interested.\n\nNow, let's talk about what I did to run it on web browser.\n\n## Ray tracer + Web Assembly\n\nThe first thing I had to do was make a decision on how JavaScript and Rust should communicate each other; more precisely, how to pass images from Rust to JavaScript.\n\n### Canvas API\n\nTo draw an image on the screen, I used the \\\u003Ccanvas\\\u003E HTML element. Its `putImageData()` API receives input image as an `ImageData` object, and the image data is given as `Uint8ClampedArray`, which is expected to be an array containing the pixel data in the RGBA order.\n\n\u003Cnuxt-image src=\"blog\u002Fray-tracer-on-web\u002Fcanvas-api.png\" alt=\"Uint8ClampedArray is used for ImageData then passed to canvas HTML element.\"\u003E\u003C\u002Fnuxt-image\u003E\n\nLong story short, the goal is to return a properly serialised `Uint8ClampedArray` from the Rust programme.\n\n### wasm-bindgen\n\n[wasm-bindgen](https:\u002F\u002Fgithub.com\u002Frustwasm\u002Fwasm-bindgen) is a library that bridges the gap between JavaScript and the Web Assembly module written in Rust.\n\nWhat I needed to do so the `render` function can be called from JavaScript and return `Uint8ClampedArray` was to add a `#[wasm_bindgen]` annotation and modify the return type:\n\n```rust\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn render(width: u16, height: u16) -\u003E Uint8ClampedArray {\n\n  \u002F\u002F ...setup a scene and a camera\n\n  let mut img = vec![];\n\n  \u002F\u002F ...build image\n\n  \u002F\u002F convert from [u8] to Uint8ClampedArray using Into trait.\n  img[..].into()\n}\n```\n\nThis is basically everything I needed to run the ray tracer in web browser, but there was one issue when I tried it: the browser got stuck while running the ray tracer. What I was missing was to follow this advice:\n\n\u003E The main thread in a browser cannot block. This means that if you run WebAssembly code on the main thread you can never block, meaning you can't do so much as acquire a mutex. This is an extremely difficult limitation to work with on the web, although one workaround is to run wasm exclusively in web workers and run JS on the main thread. It is possible to run the same wasm across all threads, but you need to be extremely vigilant about synchronization with the main thread. —— [Parallel Raytracing#caveats](https:\u002F\u002Frustwasm.github.io\u002Fwasm-bindgen\u002Fexamples\u002Fraytrace.html#caveats)\n\nBecause ray tracing takes some time and blocks the thread where it runs, running it on the main thread is a no-no; I made a first encounter to Web Worker...!\n\n### Web Worker\n\nRegardless of its unfriendly interface ([Comlink](https:\u002F\u002Fgithub.com\u002FGoogleChromeLabs\u002Fcomlink) can be a help for it), using Web Worker is not super complicated.\n\nThe main thread needs to (1) instantiate a worker specifying the path to the worker file, (2) invoke it passing arguments via `postMessage` API, and (3) listen to the result by registering an `onmessage` callback:\n\n```js\nconst w = new Worker(\"..\u002Fpath\u002Fto\u002Fthe\u002Fworker\u002Ffile\");\nw.postMessage([WIDTH, HEIGHT]);\nw.onmessage = ({ data: rendered }) =\u003E {\n  const imageData = new ImageData(rendered, WIDTH);\n  canvas.getContext(\"2d\").putImageData(imageData, 0, 0);\n};\n```\n\nThe worker in return defines an `onmessage` method, calls the wasm function, and pass back the result using `postMessage` API:\n\n```js\nonmessage = async function (e) {\n  const { render } = await import(\"wasm-raytracer\");\n  const rendered = render(e.data[0], e.data[1]);\n  postMessage(rendered);\n};\n```\n\nThis was all I needed to run ray tracer on a dedicated thread.\n\nBefore closing the section, I address the performance issue I tried to solve.\n\n### Multi-threading\n\nEven though now it's separated from the main thread, running it on a single thread takes a bit of time. To improve performance, I looked at options to run it on multiple threads.\n\nThe calculation of each pixel can be done in isolatation from each other, and _fork-join parallelism_, which is to _fork_ to start a new thread and to join to _wait_ for it to finish, can be applied using libraries such as [Rayon](https:\u002F\u002Fgithub.com\u002Frayon-rs\u002Frayon).\n\nEven though it wasn't difficult to turn the programme into the multi-thread version, there were a couple of challenges to run it in the browser environment:\n\n- WebAssembly threads are not supported by [some browsers](https:\u002F\u002Fwebassembly.org\u002Froadmap\u002F) yet.\n- To enable it, [COOP and COEP headers](https:\u002F\u002Fweb.dev\u002Fcoop-coep\u002F) need to be configured properly, which is not possble for GitHub pages where this blog is hosted as of today.\n- Because Rust's wasm build target doesn't assume it's going to be run in browsers, the standard library `std::thread` is not aware of Web Workers that enable WebAssembly threads on browser environments.\n- The [`wasm-bindgen-rayon` library](https:\u002F\u002Fgithub.com\u002FGoogleChromeLabs\u002Fwasm-bindgen-rayon) enables compiling multi-thread code written with the Rayon library into threads aware wasm, but only with the nightly version of Rust.\n\nFor those reasons, I gave up multi-threading for now hoping I can introduce it in the near future.\n\n## Why ray tracer?\n\nThis is kind of a detour from my journey of the [CPU experiment](\u002Fblog\u002Fcpu-experiment) aimed at understanding what ray tracer is and how to implement it (+ not to mention learning Rust). Next challenge is to migrate the ray tracer programme to the Hack\u002FJack system I built while I was reading the book I introduced in the last section of the [The Power of NAND](\u002Fblog\u002Fthe-power-of-nand) post. Bye for now:)\n\n## References\n\n- [Ray Tracing In One Weekend](https:\u002F\u002Fraytracing.github.io\u002Fbooks\u002FRayTracingInOneWeekend.html)\n- [The joy of building a ray tracer, for fun, in Rust.](https:\u002F\u002Fblog.singleton.io\u002Fposts\u002F2022-01-02-raytracing-with-rust\u002F)\n- [Writing a Raytracer in Rust](https:\u002F\u002Fbheisler.github.io\u002Fpost\u002Fwriting-raytracer-in-rust-part-1\u002F)\n- [Shaking Off the Rust 2: Ray Tracing in WebAssembly](https:\u002F\u002Fclayto.com\u002F2021\u002F07\u002Fshaking-off-the-rust-2-ray-tracing-in-webassembly\u002F)\n- [Parallel Raytracing](https:\u002F\u002Frustwasm.github.io\u002Fwasm-bindgen\u002Fexamples\u002Fraytrace.html)\n- [Using WebAssembly threads from C, C++ and Rust](https:\u002F\u002Fweb.dev\u002Fwebassembly-threads\u002F)\n"}}],fetch:{},mutations:void 0}}("text","element","span","token","\n","punctuation","p"," ","a","keyword","nofollow","noopener","noreferrer","_blank","code","li","(",")","true",-1,"icon","icon-link",";","operator","function",".",3,"h3","=",",","property-access","wasm-bindgen","\n  ","em","{","[","]","}",2,"h2","div","0","ul","Uint8ClampedArray","\n\n  ","postMessage","onmessage","const","method","number","References","nuxt-image","render","nuxt-content-highlight","pre","line-numbers",":","class-name","comment","string","constant","data","whats-ray-tracing","What's ray tracing?","scene","Scene","camera","Camera","ray","Ray","ray-tracer--web-assembly","Ray tracer + Web Assembly","canvas-api","Canvas API","web-worker","Web Worker","multi-threading","Multi-threading","why-ray-tracer","Why ray tracer?","references","strong","https:\u002F\u002Fraytracing.github.io\u002Fbooks\u002FRayTracingInOneWeekend.html","Ray Tracing In One Weekend","#references","ImageData","#[wasm_bindgen]","::","u16","property","language-js","new","\nw","WIDTH","function-variable","parameter"," rendered ","rendered","e","nuxt-link")));